db.collection_name.updateMany(
    { "controlsApplied.country.effectiveDate": { $exists: true } },
    [
        {
            $set: {
                controlsApplied: {
                    $map: {
                        input: "$controlsApplied",
                        as: "control",
                        in: {
                            $mergeObjects: [
                                "$$control",
                                {
                                    country: {
                                        $cond: {
                                            if: { $isObject: "$$control.country" },
                                            then: {
                                                $mergeObjects: [
                                                    "$$control.country",
                                                    {
                                                        effectiveDate: {
                                                            $cond: {
                                                                if: { $eq: ["$$control.country.effectiveDate", null] },
                                                                then: null,
                                                                else: {
                                                                    $convert: {
                                                                        input: "$$control.country.effectiveDate",
                                                                        to: "date",
                                                                        onError: null
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                ]
                                            },
                                            else: "$$control.country"
                                        }
                                    }
                                }
                            ]
                        }
                    }
                }
            }
        }
    ]
);

$(document).ready(function() {
    // Fetch the data from the backend
    $.ajax({
        url: "/api/your-endpoint",
        method: "GET",
        success: function(response) {
            // Get the container where the toggle buttons will be appended
            var container = $("#toggleContainer");

            // Loop through the data and append toggle buttons to the container
            $.each(response, function(key, value) {
                var label = $('<label class="checkbox-inline">')
                    .append(
                        $("<input>").attr({
                            type: 'checkbox',
                            class: 'toggle',
                            'data-key': key
                        }),
                        $("<span>").text(value)
                    );
                container.append(label);
            });

            // Add event listener to handle toggle state changes
            $(".toggle").on("change", function() {
                const isChecked = $(this).is(":checked");
                const state = isChecked ? "active" : "pause";
                const key = $(this).data('key');
                const dataToSend = { "key": key, "state": state };

                $.ajax({
                    url: "/your-backend-endpoint",
                    method: "POST",
                    contentType: "application/json",
                    data: JSON.stringify(dataToSend),
                    success: function(response) {
                        console.log("Server response:", response);
                    },
                    error: function(jqXHR, textStatus, errorThrown) {
                        console.error("Error:", textStatus, errorThrown);
                    }
                });
            });
        },
        error: function(jqXHR, textStatus, errorThrown) {
            console.error("Error fetching data:", textStatus, errorThrown);
        }
    });
});

$(document).ready(function() {
    // Fetch the data from the backend
    $.ajax({
        url: "/api/your-endpoint",
        method: "GET",
        success: function(response) {
            // Get the container where the toggle buttons will be appended
            var container = $("#toggleContainer");

            // Loop through the data and append toggle buttons to the container
            $.each(response, function(key, value) {
                var label = $('<label class="checkbox-inline">')
                    .append(
                        $("<input>").attr({
                            type: 'checkbox',
                            class: 'toggle',
                            'data-key': key,
                            checked: value === 'active' ? 'checked' : ''
                        }),
                        $("<span>").text(key)
                    );
                container.append(label);
            });

            // Add event listener to handle toggle state changes
            $(".toggle").on("change", function() {
                const isChecked = $(this).is(":checked");
                const state = isChecked ? "active" : "pause";
                const key = $(this).data('key');
                const dataToSend = { "key": key, "state": state };

                $.ajax({
                    url: "/your-backend-endpoint",
                    method: "POST",
                    contentType: "application/json",
                    data: JSON.stringify(dataToSend),
                    success: function(response) {
                        console.log("Server response:", response);
                    },
                    error: function(jqXHR, textStatus, errorThrown) {
                        console.error("Error:", textStatus, errorThrown);
                    }
                });
            });
        },
        error: function(jqXHR, textStatus, errorThrown) {
            console.error("Error fetching data:", textStatus, errorThrown);
        }
    });
});


$(document).ready(function() {
    // Fetch the data from the backend
    $.ajax({
        url: "/api/your-endpoint",
        method: "GET",
        success: function(response) {
            // Get the container where the toggle buttons will be appended
            var container = $("#toggleContainer");

            // Loop through the data and append toggle buttons to the container
            $.each(response, function(key, value) {
                var checkbox = $("<input>").attr({
                    type: 'checkbox',
                    class: 'toggle',
                    'data-key': key
                }).prop('checked', value === 'active');
                
                var label = $('<label class="checkbox-inline">')
                    .append(checkbox, $("<span>").text(key));
                    
                container.append(label);
            });

            // Add event listener to handle toggle state changes
            $(".toggle").on("change", function() {
                const isChecked = $(this).is(":checked");
                const state = isChecked ? "active" : "pause";
                const key = $(this).data('key');
                const dataToSend = { "key": key, "state": state };

                $.ajax({
                    url: "/your-backend-endpoint",
                    method: "POST",
                    contentType: "application/json",
                    data: JSON.stringify(dataToSend),
                    success: function(response) {
                        console.log("Server response:", response);
                    },
                    error: function(jqXHR, textStatus, errorThrown) {
                        console.error("Error:", textStatus, errorThrown);
                    }
                });
            });
        },
        error: function(jqXHR, textStatus, errorThrown) {
            console.error("Error fetching data:", textStatus, errorThrown);
        }
    });
});

$(document).ready(function() {
    // Fetch the data from the backend
    $.ajax({
        url: "/api/your-endpoint",
        method: "GET",
        success: function(response) {
            // Get the container where the toggle buttons will be appended
            var container = $("#toggleContainer");

            // Loop through the data and append toggle buttons to the container
            $.each(response, function(key, value) {
                var checkbox = $("<input>").attr({
                    type: 'checkbox',
                    class: 'toggle',
                    'data-key': key
                }).prop('checked', value === 'active');
                
                var label = $('<label>').append(checkbox, $("<span>").text(key));
                var div = $('<div class="checkbox-container">').append(label);
                    
                container.append(div);
            });

            // Add event listener to handle toggle state changes
            $(".toggle").on("change", function() {
                const isChecked = $(this).is(":checked");
                const state = isChecked ? "active" : "pause";
                const key = $(this).data('key');
                const dataToSend = { "key": key, "state": state };

                $.ajax({
                    url: "/your-backend-endpoint",
                    method: "POST",
                    contentType: "application/json",
                    data: JSON.stringify(dataToSend),
                    success: function(response) {
                        console.log("Server response:", response);
                    },
                    error: function(jqXHR, textStatus, errorThrown) {
                        console.error("Error:", textStatus, errorThrown);
                    }
                });
            });
        },
        error: function(jqXHR, textStatus, errorThrown) {
            console.error("Error fetching data:", textStatus, errorThrown);
        }
    });
});

.checkbox-container {
    margin-bottom: 10px;
}

.checkbox-container label {
    display: flex;
    align-items: center;
}

.checkbox-container label span {
    margin-left: 5px;
}

#toggleContainer {
    display: flex;
    flex-wrap: wrap;
}

.checkbox-container {
    margin-right: 20px;
    margin-bottom: 10px;
}

.checkbox-container label {
    display: flex;
    align-items: center;
}

.checkbox-container label span {
    margin-left: 5px;
}

#toggleContainer {
    display: flex;
    flex-wrap: wrap;
}

.checkbox-container {
    margin-right: 20px;
    margin-bottom: 10px;
}

.checkbox-container label {
    display: block;
}

.checkbox-container label input[type="checkbox"],
.checkbox-container label span {
    display: inline-block;
    vertical-align: middle;
}

.checkbox-container label span {
    margin-left: 5px;
}

$(document).ready(function() {
    // Fetch the data from the backend
    $.ajax({
        url: "/api/your-endpoint",
        method: "GET",
        success: function(response) {
            // Get the table where the rows will be appended
            var table = $("#toggleTable");

            // Loop through the data and append rows to the table
            $.each(response, function(key, value) {
                var checkbox = $("<input>").attr({
                    type: 'checkbox',
                    class: 'toggle',
                    'data-key': key
                }).prop('checked', value === 'active');
                
                var row = $('<tr>')
                    .append($('<td>').text(key))
                    .append($('<td>').append(checkbox));
                    
                table.append(row);
            });

            // Add event listener to handle toggle state changes
            $(".toggle").on("change", function() {
                const isChecked = $(this).is(":checked");
                const state = isChecked ? "active" : "pause";
                const key = $(this).data('key');
                const dataToSend = { "key": key, "state": state };

                $.ajax({
                    url: "/your-backend-endpoint",
                    method: "POST",
                    contentType: "application/json",
                    data: JSON.stringify(dataToSend),
                    success: function(response) {
                        console.log("Server response:", response);
                    },
                    error: function(jqXHR, textStatus, errorThrown) {
                        console.error("Error:", textStatus, errorThrown);
                    }
                });
            });
        },
        error: function(jqXHR, textStatus, errorThrown) {
            console.error("Error fetching data:", textStatus, errorThrown);
        }
    });
});

<div class="container">
    <table id="toggleTable" class="table table-striped">
        <thead>
            <tr>
                <th>Key</th>
                <th>Checkbox</th>
            </tr>
        </thead>
        <tbody>
            <!-- Rows will be added here by the JavaScript -->
        </tbody>
    </table>
</div>


$(document).ready(function() {
    // Fetch the data from the backend
    $.ajax({
        url: "/api/your-endpoint",
        method: "GET",
        success: function(response) {
            // Get the table where the rows will be appended
            var table = $("#toggleTable");

            var headerRow = $('<tr>');
            var checkboxRow = $('<tr>');

            // Loop through the data and append columns to the rows
            $.each(response, function(key, value) {
                var checkbox = $("<input>").attr({
                    type: 'checkbox',
                    class: 'toggle',
                    'data-key': key
                }).prop('checked', value === 'active');
                
                headerRow.append($('<th>').text(key));
                checkboxRow.append($('<td>').append(checkbox));
            });

            table.append(headerRow);
            table.append(checkboxRow);

            // Add event listener to handle toggle state changes
            $(".toggle").on("change", function() {
                const isChecked = $(this).is(":checked");
                const state = isChecked ? "active" : "pause";
                const key = $(this).data('key');
                const dataToSend = { "key": key, "state": state };

                $.ajax({
                    url: "/your-backend-endpoint",
                    method: "POST",
                    contentType: "application/json",
                    data: JSON.stringify(dataToSend),
                    success: function(response) {
                        console.log("Server response:", response);
                    },
                    error: function(jqXHR, textStatus, errorThrown) {
                        console.error("Error:", textStatus, errorThrown);
                    }
                });
            });
        },
        error: function(jqXHR, textStatus, errorThrown) {
            console.error("Error fetching data:", textStatus, errorThrown);
        }
    });
});

{
    "name": "Person",
    "type": "record",
    "fields": [
        {"name": "firstName", "type": "string"},
        {"name": "lastName", "type": "string"},
        {"name": "age", "type": "int"}
    ]
}

{
    "name": "Person",
    "type": "record",
    "fields": [
        {"name": "firstName", "type": "string"},
        {"name": "lastName", "type": "string"},
        {"name": "age", "type": "int"},
        {"name": "email", "type": ["null", "string"], "default": null}
    ]
}

Old data without an email field can be read by new code. The email field will simply be assigned the default value of null.

New data with an email field can also be read by old code. The email field will simply be ignored if the code does not know how to handle it.




public class CustomKafkaConsumer<K, V> {

    private final KafkaMessageListenerContainer<K, V> container;
    private final String topic;
    private final MessageHandler<K, V> messageHandler;
    private final Auditor<K, V> auditor;
    private ConsumerConfiguration configuration;
    private ErrorHandler errorHandler;

    public CustomKafkaConsumer(String topic, MessageHandler<K, V> messageHandler) {
        this(topic, messageHandler, new ConsumerConfiguration(), new DefaultErrorHandler(), new ConsoleAuditor<>());
    }

    public CustomKafkaConsumer(String topic, MessageHandler<K, V> messageHandler, ConsumerConfiguration configuration) {
        this(topic, messageHandler, configuration, new DefaultErrorHandler(), new ConsoleAuditor<>());
    }

    public CustomKafkaConsumer(String topic, MessageHandler<K, V> messageHandler, ConsumerConfiguration configuration, ErrorHandler errorHandler) {
        this(topic, messageHandler, configuration, errorHandler, new ConsoleAuditor<>());
    }

    public CustomKafkaConsumer(String topic, MessageHandler<K, V> messageHandler, ConsumerConfiguration configuration, ErrorHandler errorHandler, Auditor<K, V> auditor) {
        this.topic = topic;
        this.messageHandler = messageHandler;
        this.configuration = configuration;
        this.errorHandler = errorHandler;
        this.auditor = auditor;

        ConcurrentKafkaListenerContainerFactory<K, V> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(new DefaultKafkaConsumerFactory<>(this.configuration.getProps()));
        factory.setErrorHandler(this.errorHandler);
        this.container = factory.createContainer(this.topic);
        this.init();
    }

    private void init() {
        container.setupMessageListener(new MessageListener<K, V>() {
            @Override
            public void onMessage(ConsumerRecord<K, V> data) {
                auditor.audit(data);
                messageHandler.handle(data);
            }
        });
    }

    public void start() {
        container.start();
    }

    public void stop() {
        container.stop();
    }

}



<build>
    <plugins>
        <plugin>
            <artifactId>maven-assembly-plugin</artifactId>
            <version>3.3.0</version>
            <configuration>
                <archive>
                    <manifest>
                        <mainClass>com.example.Main</mainClass>
                    </manifest>
                </archive>
                <descriptorRefs>
                    <descriptorRef>jar-with-dependencies</descriptorRef>
                </descriptorRefs>
            </configuration>
            <executions>
                <execution>
                    <id>make-assembly</id>
                    <phase>package</phase>
                    <goals>
                        <goal>single</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>


import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

@Component
public class MyKafkaListenerAnnotationBeanPostProcessor implements BeanPostProcessor, ApplicationContextAware {
    
    private ApplicationContext applicationContext;
    private MyKafkaProperties myKafkaProperties;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
        this.myKafkaProperties = applicationContext.getBean(MyKafkaProperties.class);
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        Method[] methods = ReflectionUtils.getAllDeclaredMethods(bean.getClass());
        if (methods != null) {
            for (Method method : methods) {
                MyKafkaListener myKafkaListener = AnnotatedElementUtils.findMergedAnnotation(method, MyKafkaListener.class);
                if (myKafkaListener != null) {
                    KafkaListenerConfigurer kafkaListenerConfigurer = new KafkaListenerConfigurer(applicationContext, myKafkaProperties);
                    kafkaListenerConfigurer.configureKafkaListeners(myKafkaListener, bean, method);
                }
            }
        }
        return bean;
    }
}


import org.springframework.context.ApplicationContext;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.config.KafkaListenerConfigurer;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.listener.ContainerProperties;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class MyKafkaListenerConfigurer implements KafkaListenerConfigurer {

    private final MyKafkaProperties myKafkaProperties;
    private final ApplicationContext applicationContext;
    private final Map<String, ConcurrentKafkaListenerContainerFactory<String, String>> containerFactories = new ConcurrentHashMap<>();

    public MyKafkaListenerConfigurer(MyKafkaProperties myKafkaProperties, ApplicationContext applicationContext) {
        this.myKafkaProperties = myKafkaProperties;
        this.applicationContext = applicationContext;
    }

    @Override
    public void configureKafkaListeners(KafkaListenerEndpointRegistrar registrar) {
        applicationContext.getBeansWithAnnotation(MyKafkaListener.class).forEach((beanName, bean) ->
            Arrays.stream(bean.getClass().getMethods())
                .filter(method -> method.isAnnotationPresent(MyKafkaListener.class))
                .forEach(method -> {
                    MyKafkaListener myKafkaListener = AnnotationUtils.findAnnotation(method, MyKafkaListener.class);
                    if (myKafkaListener != null) {
                        configureKafkaListener(myKafkaListener, bean, method, registrar);
                    }
                })
        );
    }

    private void configureKafkaListener(MyKafkaListener myKafkaListener, Object bean, Method method, KafkaListenerEndpointRegistrar registrar) {
        String propertiesRef = myKafkaListener.propertiesRef();
        Map<String, Object> properties = myKafkaProperties.get(propertiesRef);
        ConsumerFactory<String, String> consumerFactory = new DefaultKafkaConsumerFactory<>(properties);

        ConcurrentKafkaListenerContainerFactory<String, String> containerFactory = containerFactories.computeIfAbsent(propertiesRef, k -> {
            ConcurrentKafkaListenerContainerFactory<String, String> newContainerFactory = new ConcurrentKafkaListenerContainerFactory<>();
            newContainerFactory.setConsumerFactory(consumerFactory);
            newContainerFactory.setConcurrency(myKafkaListener.concurrency());
            newContainerFactory.getContainerProperties().setAckMode(ContainerProperties.AckMode.MANUAL);
            return newContainerFactory;
        });

        SimpleKafkaListenerEndpoint<String, String> endpoint = new SimpleKafkaListenerEndpoint<>();
        endpoint.setId(UUID.randomUUID().toString());
        endpoint.setBean(bean);
        endpoint.setMethod(method);
        endpoint.setContainerFactory(containerFactory);
        registrar.registerEndpoint(endpoint);
    }
}

.....
@Component
public class MyKafkaListenerAnnotationBeanPostProcessor extends AbstractBeanFactoryAwareAdvisingPostProcessor {

    @Autowired
    private KafkaListenerEndpointRegistrar registrar;

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        // Get all methods in the bean
        Method[] methods = ReflectionUtils.getAllDeclaredMethods(bean.getClass());

        if (methods != null) {
            for (Method method : methods) {
                // Check if the method is annotated with @MyKafkaListener
                MyKafkaListener myKafkaListener = AnnotatedElementUtils.findMergedAnnotation(method, MyKafkaListener.class);

                if (myKafkaListener != null) {
                    // Create an endpoint for this method
                    MyKafkaListenerEndpoint<String, String> endpoint = new MyKafkaListenerEndpoint<>();

                    // Configure the endpoint (ID, group, topic, etc.)
                    endpoint.setId(UUID.randomUUID().toString());
                    endpoint.setGroupId(myKafkaListener.groupId());
                    endpoint.setTopics(myKafkaListener.topic());

                    // Register the endpoint with the registrar
                    registrar.registerEndpoint(endpoint);
                }
            }
        }

        return bean;
    }
}


@Configuration
public class MyKafkaListenerConfigurer implements KafkaListenerConfigurer {

    @Autowired
    private ApplicationContext applicationContext;

    @Autowired
    private MyKafkaProperties myKafkaProperties;

    @Override
    public void configureKafkaListeners(KafkaListenerEndpointRegistrar registrar) {
        // Iterate over all registered endpoints
        for (KafkaListenerEndpoint endpoint : registrar.getEndpoints()) {
            // Check if the endpoint is an instance of MyKafkaListenerEndpoint
            if (endpoint instanceof MyKafkaListenerEndpoint) {
                // Cast the endpoint to MyKafkaListenerEndpoint
                MyKafkaListenerEndpoint myKafkaListenerEndpoint = (MyKafkaListenerEndpoint) endpoint;

                // Get the properties for this endpoint
                Map<String, String> properties = myKafkaProperties.get(myKafkaListenerEndpoint.getPropertiesRef());

                // Create a container factory for this endpoint
                ConsumerFactory<String, String> consumerFactory = new DefaultKafkaConsumerFactory<>(properties);
                ConcurrentKafkaListenerContainerFactory<String, String> containerFactory = new ConcurrentKafkaListenerContainerFactory<>();
                containerFactory.setConsumerFactory(consumerFactory);

                // Set the container factory for this endpoint
                myKafkaListenerEndpoint.setContainerFactory(containerFactory);
            }
        }
    }
}




public void printRecordMetadata(ConsumerRecord<?, ?> record) {
    String metadata = String.format(
        "Topic: %s | Partition: %d | Offset: %d | Timestamp: %d | Key: %s | Value: %s",
        record.topic(),
        record.partition(),
        record.offset(),
        record.timestamp(),
        record.key(),
        record.value()
    );

    System.out.println(metadata);
}



import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.annotation.EnableKafka;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.listener.config.ConcurrentKafkaListenerContainerFactory;

import java.util.HashMap;
import java.util.Map;

@Configuration
@EnableKafka
public class KafkaConfig {

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, String> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, String> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
        return factory;
    }

    @Bean
    public ConsumerFactory<String, String> consumerFactory() {
        Map<String, Object> config = new HashMap<>();
        config.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        config.put(ConsumerConfig.GROUP_ID_CONFIG, "test-group");
        config.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        config.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        return new DefaultKafkaConsumerFactory<>(config);
    }
}


